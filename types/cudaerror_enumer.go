// Code generated by "enumer -type=CUDAError -json -text -yaml -sql"; DO NOT EDIT.

//
package types

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
)

const (
	_CUDAErrorName_0 = "CUDASuccessCUDAErrorMissingConfigurationCUDAErrorMemoryAllocationCUDAErrorInitializationErrorCUDAErrorLaunchFailureCUDAErrorPriorLaunchFailureCUDAErrorLaunchTimeoutCUDAErrorLaunchOutOfResourcesCUDAErrorInvalidDeviceFunctionCUDAErrorInvalidConfigurationCUDAErrorInvalidDeviceCUDAErrorInvalidValueCUDAErrorInvalidPitchValueCUDAErrorInvalidSymbolCUDAErrorMapBufferObjectFailedCUDAErrorUnmapBufferObjectFailedCUDAErrorInvalidHostPointerCUDAErrorInvalidDevicePointerCUDAErrorInvalidTextureCUDAErrorInvalidTextureBindingCUDAErrorInvalidChannelDescriptorCUDAErrorInvalidMemcpyDirectionCUDAErrorAddressOfConstantCUDAErrorTextureFetchFailedCUDAErrorTextureNotBoundCUDAErrorSynchronizationErrorCUDAErrorInvalidFilterSettingCUDAErrorInvalidNormSettingCUDAErrorMixedDeviceExecutionCUDAErrorCudartUnloadingCUDAErrorUnknownCUDAErrorNotYetImplementedCUDAErrorMemoryValueTooLargeCUDAErrorInvalidResourceHandleCUDAErrorNotReadyCUDAErrorInsufficientDriverCUDAErrorSetOnActiveProcessCUDAErrorInvalidSurfaceCUDAErrorNoDeviceCUDAErrorECCUncorrectableCUDAErrorSharedObjectSymbolNotFoundCUDAErrorSharedObjectInitFailedCUDAErrorUnsupportedLimitCUDAErrorDuplicateVariableNameCUDAErrorDuplicateTextureNameCUDAErrorDuplicateSurfaceNameCUDAErrorDevicesUnavailableCUDAErrorInvalidKernelImageCUDAErrorNoKernelImageForDeviceCUDAErrorIncompatibleDriverContextCUDAErrorPeerAccessAlreadyEnabledCUDAErrorPeerAccessNotEnabled"
	_CUDAErrorName_1 = "CUDAErrorDeviceAlreadyInUseCUDAErrorProfilerDisabledCUDAErrorProfilerNotInitializedCUDAErrorProfilerAlreadyStartedCUDAErrorProfilerAlreadyStoppedCUDAErrorAssertCUDAErrorTooManyPeersCUDAErrorHostMemoryAlreadyRegisteredCUDAErrorHostMemoryNotRegisteredCUDAErrorOperatingSystemCUDAErrorPeerAccessUnsupportedCUDAErrorLaunchMaxDepthExceededCUDAErrorLaunchFileScopedTexCUDAErrorLaunchFileScopedSurfCUDAErrorSyncDepthExceededCUDAErrorLaunchPendingCountExceededCUDAErrorNotPermittedCUDAErrorNotSupportedCUDAErrorHardwareStackErrorCUDAErrorIllegalInstructionCUDAErrorMisalignedAddressCUDAErrorInvalidAddressSpaceCUDAErrorInvalidPcCUDAErrorIllegalAddressCUDAErrorInvalidPtxCUDAErrorInvalidGraphicsContextCUDAErrorNvlinkUncorrectableCUDAErrorJitCompilerNotFoundCUDAErrorCooperativeLaunchTooLarge"
	_CUDAErrorName_2 = "CUDAErrorStartupFailure"
	_CUDAErrorName_3 = "CUDAErrorApiFailureBase"
)

var (
	_CUDAErrorIndex_0 = [...]uint16{0, 11, 40, 65, 93, 115, 142, 164, 193, 223, 252, 274, 295, 321, 343, 373, 405, 432, 461, 484, 514, 547, 578, 604, 631, 655, 684, 713, 740, 769, 793, 809, 835, 863, 893, 910, 937, 964, 987, 1004, 1029, 1064, 1095, 1120, 1150, 1179, 1208, 1235, 1262, 1293, 1327, 1360, 1389}
	_CUDAErrorIndex_1 = [...]uint16{0, 27, 52, 83, 114, 145, 160, 181, 217, 249, 273, 303, 334, 362, 391, 417, 452, 473, 494, 521, 548, 574, 602, 620, 643, 662, 693, 721, 749, 783}
	_CUDAErrorIndex_2 = [...]uint8{0, 23}
	_CUDAErrorIndex_3 = [...]uint8{0, 23}
)

func (i CUDAError) String() string {
	switch {
	case 0 <= i && i <= 51:
		return _CUDAErrorName_0[_CUDAErrorIndex_0[i]:_CUDAErrorIndex_0[i+1]]
	case 54 <= i && i <= 82:
		i -= 54
		return _CUDAErrorName_1[_CUDAErrorIndex_1[i]:_CUDAErrorIndex_1[i+1]]
	case i == 127:
		return _CUDAErrorName_2
	case i == 10000:
		return _CUDAErrorName_3
	default:
		return fmt.Sprintf("CUDAError(%d)", i)
	}
}

var _CUDAErrorValues = []CUDAError{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 127, 10000}

var _CUDAErrorNameToValueMap = map[string]CUDAError{
	_CUDAErrorName_0[0:11]:      0,
	_CUDAErrorName_0[11:40]:     1,
	_CUDAErrorName_0[40:65]:     2,
	_CUDAErrorName_0[65:93]:     3,
	_CUDAErrorName_0[93:115]:    4,
	_CUDAErrorName_0[115:142]:   5,
	_CUDAErrorName_0[142:164]:   6,
	_CUDAErrorName_0[164:193]:   7,
	_CUDAErrorName_0[193:223]:   8,
	_CUDAErrorName_0[223:252]:   9,
	_CUDAErrorName_0[252:274]:   10,
	_CUDAErrorName_0[274:295]:   11,
	_CUDAErrorName_0[295:321]:   12,
	_CUDAErrorName_0[321:343]:   13,
	_CUDAErrorName_0[343:373]:   14,
	_CUDAErrorName_0[373:405]:   15,
	_CUDAErrorName_0[405:432]:   16,
	_CUDAErrorName_0[432:461]:   17,
	_CUDAErrorName_0[461:484]:   18,
	_CUDAErrorName_0[484:514]:   19,
	_CUDAErrorName_0[514:547]:   20,
	_CUDAErrorName_0[547:578]:   21,
	_CUDAErrorName_0[578:604]:   22,
	_CUDAErrorName_0[604:631]:   23,
	_CUDAErrorName_0[631:655]:   24,
	_CUDAErrorName_0[655:684]:   25,
	_CUDAErrorName_0[684:713]:   26,
	_CUDAErrorName_0[713:740]:   27,
	_CUDAErrorName_0[740:769]:   28,
	_CUDAErrorName_0[769:793]:   29,
	_CUDAErrorName_0[793:809]:   30,
	_CUDAErrorName_0[809:835]:   31,
	_CUDAErrorName_0[835:863]:   32,
	_CUDAErrorName_0[863:893]:   33,
	_CUDAErrorName_0[893:910]:   34,
	_CUDAErrorName_0[910:937]:   35,
	_CUDAErrorName_0[937:964]:   36,
	_CUDAErrorName_0[964:987]:   37,
	_CUDAErrorName_0[987:1004]:  38,
	_CUDAErrorName_0[1004:1029]: 39,
	_CUDAErrorName_0[1029:1064]: 40,
	_CUDAErrorName_0[1064:1095]: 41,
	_CUDAErrorName_0[1095:1120]: 42,
	_CUDAErrorName_0[1120:1150]: 43,
	_CUDAErrorName_0[1150:1179]: 44,
	_CUDAErrorName_0[1179:1208]: 45,
	_CUDAErrorName_0[1208:1235]: 46,
	_CUDAErrorName_0[1235:1262]: 47,
	_CUDAErrorName_0[1262:1293]: 48,
	_CUDAErrorName_0[1293:1327]: 49,
	_CUDAErrorName_0[1327:1360]: 50,
	_CUDAErrorName_0[1360:1389]: 51,
	_CUDAErrorName_1[0:27]:      54,
	_CUDAErrorName_1[27:52]:     55,
	_CUDAErrorName_1[52:83]:     56,
	_CUDAErrorName_1[83:114]:    57,
	_CUDAErrorName_1[114:145]:   58,
	_CUDAErrorName_1[145:160]:   59,
	_CUDAErrorName_1[160:181]:   60,
	_CUDAErrorName_1[181:217]:   61,
	_CUDAErrorName_1[217:249]:   62,
	_CUDAErrorName_1[249:273]:   63,
	_CUDAErrorName_1[273:303]:   64,
	_CUDAErrorName_1[303:334]:   65,
	_CUDAErrorName_1[334:362]:   66,
	_CUDAErrorName_1[362:391]:   67,
	_CUDAErrorName_1[391:417]:   68,
	_CUDAErrorName_1[417:452]:   69,
	_CUDAErrorName_1[452:473]:   70,
	_CUDAErrorName_1[473:494]:   71,
	_CUDAErrorName_1[494:521]:   72,
	_CUDAErrorName_1[521:548]:   73,
	_CUDAErrorName_1[548:574]:   74,
	_CUDAErrorName_1[574:602]:   75,
	_CUDAErrorName_1[602:620]:   76,
	_CUDAErrorName_1[620:643]:   77,
	_CUDAErrorName_1[643:662]:   78,
	_CUDAErrorName_1[662:693]:   79,
	_CUDAErrorName_1[693:721]:   80,
	_CUDAErrorName_1[721:749]:   81,
	_CUDAErrorName_1[749:783]:   82,
	_CUDAErrorName_2[0:23]:      127,
	_CUDAErrorName_3[0:23]:      10000,
}

// CUDAErrorString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func CUDAErrorString(s string) (CUDAError, error) {
	if val, ok := _CUDAErrorNameToValueMap[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to CUDAError values", s)
}

// CUDAErrorValues returns all values of the enum
func CUDAErrorValues() []CUDAError {
	return _CUDAErrorValues
}

// IsACUDAError returns "true" if the value is listed in the enum definition. "false" otherwise
func (i CUDAError) IsACUDAError() bool {
	for _, v := range _CUDAErrorValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for CUDAError
func (i CUDAError) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for CUDAError
func (i *CUDAError) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("CUDAError should be a string, got %s", data)
	}

	var err error
	*i, err = CUDAErrorString(s)
	return err
}

// MarshalText implements the encoding.TextMarshaler interface for CUDAError
func (i CUDAError) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for CUDAError
func (i *CUDAError) UnmarshalText(text []byte) error {
	var err error
	*i, err = CUDAErrorString(string(text))
	return err
}

// MarshalYAML implements a YAML Marshaler for CUDAError
func (i CUDAError) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for CUDAError
func (i *CUDAError) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = CUDAErrorString(s)
	return err
}

func (i CUDAError) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *CUDAError) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	str, ok := value.(string)
	if !ok {
		bytes, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("value is not a byte slice")
		}

		str = string(bytes[:])
	}

	val, err := CUDAErrorString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}
